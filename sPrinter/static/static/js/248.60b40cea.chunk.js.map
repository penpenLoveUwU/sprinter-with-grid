{"version":3,"file":"static/js/248.60b40cea.chunk.js","mappings":"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","sources":["../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","../node_modules/@babel/runtime/helpers/esm/toPrimitive.js","../node_modules/@babel/runtime/helpers/esm/createClass.js","utils/colors/MapAreaVertex.js","utils/colors/MapAreaGraph.js","utils/colors/FourColorTheoremSolver.js","utils/colors/ColorUtils.js","MapLayerManagerUtils.js","MapLayerManager.worker.js"],"sourcesContent":["export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nexport default function _toPropertyKey(arg) {\n  var key = toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}","import _typeof from \"./typeof.js\";\nexport default function _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}","import toPropertyKey from \"./toPropertyKey.js\";\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);\n  }\n}\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}","export class MapAreaVertex {\n    constructor(id) {\n        this.id = id;\n        this.adjacentVertexIds = new Set();\n        this.color = undefined;\n    }\n    appendVertex(vertexId) {\n        if (vertexId !== undefined) {\n            this.adjacentVertexIds.add(vertexId);\n        }\n    }\n}","export class MapAreaGraph {\n    constructor(vertices) {\n        this.vertices = vertices;\n        this.vertexLookup = new Map();\n        this.vertices.forEach((v) => {\n            this.vertexLookup.set(v.id, v);\n        });\n    }\n    connectVertices(id1, id2) {\n        if (id1 !== undefined && id2 !== undefined && id1 !== id2) {\n            if (this.vertexLookup.has(id1)) {\n                this.vertexLookup.get(id1).appendVertex(id2);\n            }\n            if (this.vertexLookup.has(id2)) {\n                this.vertexLookup.get(id2).appendVertex(id1);\n            }\n        }\n    }\n    /**\n     * Color the graphs vertices using a greedy algorithm. Any vertices that have already been assigned a color will not be changed.\n     * Color assignment will start with the vertex that is connected with the highest number of edges. In most cases, this will\n     * naturally lead to a distribution where only four colors are required for the whole graph. This is relevant for maps with a high\n     * number of segments, as the naive, greedy algorithm tends to require a fifth color when starting coloring in a segment far from the map's center.\n     *\n     */\n    colorAllVertices() {\n        this.vertices.sort((l, r) => {\n            return r.adjacentVertexIds.size - l.adjacentVertexIds.size;\n        });\n        this.vertices.forEach((v) => {\n            if (v.adjacentVertexIds.size <= 0) {\n                v.color = 0;\n            }\n            else {\n                const adjacentVertices = this.getAdjacentVertices(v);\n                const existingColors = adjacentVertices\n                    .filter((vert) => {\n                    return vert.color !== undefined;\n                })\n                    .map((vert) => {\n                    return vert.color;\n                });\n                v.color = this.lowestColor(existingColors);\n            }\n        });\n    }\n    getAdjacentVertices(vertex) {\n        return Array.from(vertex.adjacentVertexIds).map((id) => {\n            return this.getById(id);\n        }).filter(adjacentVertex => {\n            return adjacentVertex !== undefined;\n        });\n    }\n    getById(id) {\n        return this.vertices.find((v) => {\n            return v.id === id;\n        });\n    }\n    lowestColor(colors) {\n        if (colors.length <= 0) {\n            return 0;\n        }\n        for (let index = 0; index < colors.length + 1; index++) {\n            if (!colors.includes(index)) {\n                return index;\n            }\n        }\n    }\n}","import { MapAreaVertex } from \"./MapAreaVertex\";\nimport { MapAreaGraph } from \"./MapAreaGraph\";\nimport { create2DArray } from \"./ColorUtils\";\nexport class FourColorTheoremSolver {\n    constructor(layers, pixelSize) {\n        /**\n         * @param {number} resolution - Minimal resolution of the map scanner in pixels. Any number higher than one will lead to this many pixels being skipped when finding segment boundaries.\n         * For example: If the robot measures 30cm in length/width, this should be set to 6, as no room can be smaller than 6 pixels. This of course implies that a pixel represents 5cm in the real world.\n         */\n        const resolution = Math.floor(30 / pixelSize);\n        this.stepFunction = function (c) {\n            return c + resolution;\n        };\n        const preparedLayers = this.preprocessLayers(layers);\n        if (preparedLayers !== undefined) {\n            const mapData = this.createPixelToSegmentMapping(preparedLayers);\n            this.areaGraph = this.buildGraph(mapData);\n            this.areaGraph.colorAllVertices();\n        }\n    }\n    /*\n     * @param {string} segmentId - ID of the segment you want to get the color for.\n     * The segment ID is extracted from the layer meta data in the first contructor parameter of this class.\n     * @returns {number} The segment color, represented as an integer. Starts at 0 and goes up the minimal number of colors required to color the map without collisions.\n     */\n    getColor(segmentId) {\n        if (this.areaGraph === undefined) {\n            // Layer preprocessing seems to have failed. Just return a default value for any input.\n            return 0;\n        }\n        const segmentFromGraph = this.areaGraph.getById(segmentId);\n        if (segmentFromGraph && segmentFromGraph.color !== undefined) {\n            return segmentFromGraph.color;\n        }\n        else {\n            return 0;\n        }\n    }\n    preprocessLayers(layers) {\n        const internalSegments = [];\n        const boundaries = {\n            minX: Infinity,\n            maxX: -Infinity,\n            minY: Infinity,\n            maxY: -Infinity,\n        };\n        const filteredLayers = layers.filter((layer) => {\n            return layer.type === \"segment\";\n        });\n        if (filteredLayers.length <= 0) {\n            return undefined;\n        }\n        filteredLayers.forEach((layer) => {\n            const allPixels = [];\n            for (let index = 0; index < layer.pixels.length - 1; index += 2) {\n                const p = {\n                    x: layer.pixels[index],\n                    y: layer.pixels[index + 1],\n                };\n                FourColorTheoremSolver.setBoundaries(boundaries, p);\n                allPixels.push(p);\n            }\n            if (layer.metaData.segmentId !== undefined) {\n                internalSegments.push({\n                    segmentId: layer.metaData.segmentId,\n                    name: layer.metaData.name,\n                    pixels: allPixels,\n                });\n            }\n        });\n        return {\n            boundaries: boundaries,\n            segments: internalSegments,\n        };\n    }\n    static setBoundaries(res, pixel) {\n        if (pixel.x < res.minX) {\n            res.minX = pixel.x;\n        }\n        if (pixel.y < res.minY) {\n            res.minY = pixel.y;\n        }\n        if (pixel.x > res.maxX) {\n            res.maxX = pixel.x;\n        }\n        if (pixel.y > res.maxY) {\n            res.maxY = pixel.y;\n        }\n    }\n    createPixelToSegmentMapping(preparedLayers) {\n        const pixelData = create2DArray(preparedLayers.boundaries.maxX + 1, preparedLayers.boundaries.maxY + 1);\n        const segmentIds = [];\n        preparedLayers.segments.forEach((seg) => {\n            segmentIds.push(seg.segmentId);\n            seg.pixels.forEach((p) => {\n                pixelData[p.x][p.y] = seg.segmentId;\n            });\n        });\n        return {\n            map: pixelData,\n            segmentIds: segmentIds,\n            boundaries: preparedLayers.boundaries,\n        };\n    }\n    buildGraph(mapData) {\n        const vertices = mapData.segmentIds.map((i) => {\n            return new MapAreaVertex(i);\n        });\n        const graph = new MapAreaGraph(vertices);\n        this.traverseMap(mapData.boundaries, mapData.map, (x, y, currentSegmentId, pixelData) => {\n            const newSegmentId = pixelData[x][y];\n            graph.connectVertices(currentSegmentId, newSegmentId);\n            return newSegmentId !== undefined ? newSegmentId : currentSegmentId;\n        });\n        return graph;\n    }\n    traverseMap(boundaries, pixelData, func) {\n        // row-first traversal\n        for (let y = boundaries.minY; y <= boundaries.maxY; y = this.stepFunction(y)) {\n            let rowFirstSegmentId = undefined;\n            for (let x = boundaries.minX; x <= boundaries.maxX; x = this.stepFunction(x)) {\n                rowFirstSegmentId = func(x, y, rowFirstSegmentId, pixelData);\n            }\n        }\n        // column-first traversal\n        for (let x = boundaries.minX; x <= boundaries.maxX; x = this.stepFunction(x)) {\n            let colFirstSegmentId = undefined;\n            for (let y = boundaries.minY; y <= boundaries.maxY; y = this.stepFunction(y)) {\n                colFirstSegmentId = func(x, y, colFirstSegmentId, pixelData);\n            }\n        }\n    }\n}","\nexport function create2DArray(xLength, yLength) {\n    return [...new Array(xLength)].map(elem => {\n        return [...new Array(yLength)];\n    });\n}","import { FourColorTheoremSolver } from \"./utils/colors/FourColorTheoremSolver\";\nexport function PROCESS_LAYERS(layers, pixelSize, colors, backgroundColors, selectedSegmentIds = []) {\n    const dimensions = CALCULATE_REQUIRED_DIMENSIONS(layers);\n    const width = dimensions.x.sum;\n    const height = dimensions.y.sum;\n    const pixelData = new Uint8ClampedArray(width * height * 4);\n    const segmentLookupData = new Uint8ClampedArray(width * height);\n    const segmentLookupIdMapping = new Map(); //Because segment IDs are arbitrary strings, we need this mapping to an int for the lookup data\n    const colorFinder = new FourColorTheoremSolver(layers, pixelSize);\n    const hasSelectedSegments = selectedSegmentIds.length === 0;\n    [...layers].sort((a, b) => {\n        return TYPE_SORT_MAPPING[a.type] - TYPE_SORT_MAPPING[b.type];\n    }).forEach(layer => {\n        let color;\n        switch (layer.type) {\n            case \"floor\":\n                if (hasSelectedSegments) {\n                    color = colors.floor;\n                }\n                else {\n                    color = backgroundColors.floor;\n                }\n                break;\n            case \"wall\":\n                if (hasSelectedSegments) {\n                    color = colors.wall;\n                }\n                else {\n                    color = backgroundColors.wall;\n                }\n                break;\n            case \"segment\": {\n                if (hasSelectedSegments || selectedSegmentIds.includes(layer.metaData.segmentId ?? \"\")) {\n                    color = colors.segments[colorFinder.getColor((layer.metaData.segmentId ?? \"\"))];\n                }\n                else {\n                    color = backgroundColors.segments[colorFinder.getColor((layer.metaData.segmentId ?? \"\"))];\n                }\n                break;\n            }\n        }\n        if (!color) {\n            // eslint-disable-next-line no-console\n            console.error(`Missing color for ${layer.type} with segment id '${layer.metaData.segmentId}'.`);\n            color = { r: 128, g: 128, b: 128 };\n        }\n        let segmentLookupId = 0;\n        if (layer.metaData.segmentId) {\n            segmentLookupId = segmentLookupIdMapping.size + 1;\n            segmentLookupIdMapping.set(segmentLookupId, layer.metaData.segmentId);\n        }\n        for (let i = 0; i < layer.pixels.length; i = i + 2) {\n            const offset = ((layer.pixels[i] - dimensions.x.min) +\n                ((layer.pixels[i + 1] - dimensions.y.min) * width));\n            const imgDataOffset = offset * 4;\n            pixelData[imgDataOffset] = color.r;\n            pixelData[imgDataOffset + 1] = color.g;\n            pixelData[imgDataOffset + 2] = color.b;\n            pixelData[imgDataOffset + 3] = 255;\n            segmentLookupData[offset] = segmentLookupId;\n        }\n    });\n    return {\n        pixelData: pixelData,\n        width: dimensions.x.sum,\n        height: dimensions.y.sum,\n        left: dimensions.x.min,\n        top: dimensions.y.min,\n        segmentLookupData: segmentLookupData,\n        segmentLookupIdMapping: Object.fromEntries(segmentLookupIdMapping)\n    };\n}\nfunction CALCULATE_REQUIRED_DIMENSIONS(layers) {\n    const dimensions = {\n        x: {\n            min: Infinity,\n            max: -Infinity,\n            sum: 0,\n        },\n        y: {\n            min: Infinity,\n            max: -Infinity,\n            sum: 0,\n        },\n    };\n    layers.forEach(layer => {\n        dimensions.x.min = layer.dimensions.x.min < dimensions.x.min ? layer.dimensions.x.min : dimensions.x.min;\n        dimensions.x.max = layer.dimensions.x.max > dimensions.x.max ? layer.dimensions.x.max : dimensions.x.max;\n        dimensions.y.min = layer.dimensions.y.min < dimensions.y.min ? layer.dimensions.y.min : dimensions.y.min;\n        dimensions.y.max = layer.dimensions.y.max > dimensions.y.max ? layer.dimensions.y.max : dimensions.y.max;\n    });\n    dimensions.x.sum = (dimensions.x.max - dimensions.x.min) + 1;\n    dimensions.y.sum = (dimensions.y.max - dimensions.y.min) + 1;\n    dimensions.x.sum = isFinite(dimensions.x.sum) ? dimensions.x.sum : 0;\n    dimensions.y.sum = isFinite(dimensions.y.sum) ? dimensions.y.sum : 0;\n    return dimensions;\n}\n// This is important because it determines the draw order\nconst TYPE_SORT_MAPPING = {\n    \"floor\": 14,\n    \"segment\": 15,\n    \"wall\": 16\n};","import { PROCESS_LAYERS } from \"./MapLayerManagerUtils\";\n\nconsole.log('MapLayerManager.worker is running in', this === undefined ? 'strict' : 'non-strict', 'mode');\n\nlet cachedLayers = [];\nwindow.self.postMessage({\n    ready: true\n});\nwindow.self.addEventListener(\"message\", (evt) => {\n    //According to SonarJS S2819, this might be problematic\n    //I honestly have no idea if this check is actually needed in a webworker context, but I'll do as the tool says.\n    // if (evt.origin !== \"\") {\n    //     // eslint-disable-next-line no-console\n    //     console.warn(`Received event with unexpected origin \"${evt.origin}\"`);\n    //     return;\n    // }\n    if (evt.data.mapLayers) {\n        cachedLayers = evt.data.mapLayers;\n    }\n    const rendered = PROCESS_LAYERS(cachedLayers, evt.data.pixelSize, evt.data.colors, evt.data.backgroundColors, evt.data.selectedSegmentIds);\n    window.self.postMessage({\n        pixelData: rendered.pixelData.buffer,\n        width: rendered.width,\n        height: rendered.height,\n        left: rendered.left,\n        top: rendered.top,\n        segmentLookupData: rendered.segmentLookupData.buffer,\n        segmentLookupIdMapping: rendered.segmentLookupIdMapping\n    }, {\n        transfer: [\n            rendered.pixelData.buffer,\n            rendered.segmentLookupData.buffer\n        ]\n    });\n});"],"names":["_arrayLikeToArray","arr","len","length","i","arr2","Array","_toConsumableArray","isArray","iter","Symbol","iterator","from","o","minLen","n","Object","prototype","toString","call","slice","constructor","name","test","TypeError","_classCallCheck","instance","Constructor","_typeof","obj","_toPropertyKey","arg","key","input","hint","prim","toPrimitive","undefined","res","String","Number","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","_createClass","protoProps","staticProps","MapAreaVertex","id","this","adjacentVertexIds","Set","color","value","vertexId","add","MapAreaGraph","vertices","_this","vertexLookup","Map","forEach","v","set","id1","id2","has","get","appendVertex","_this2","sort","l","r","size","existingColors","getAdjacentVertices","filter","vert","map","lowestColor","vertex","_this3","getById","adjacentVertex","find","colors","index","includes","FourColorTheoremSolver","layers","pixelSize","resolution","Math","floor","stepFunction","c","preparedLayers","preprocessLayers","mapData","createPixelToSegmentMapping","areaGraph","buildGraph","colorAllVertices","segmentId","segmentFromGraph","internalSegments","boundaries","minX","Infinity","maxX","minY","maxY","filteredLayers","layer","type","allPixels","pixels","p","x","y","setBoundaries","push","metaData","segments","xLength","yLength","pixelData","elem","segmentIds","seg","graph","traverseMap","currentSegmentId","newSegmentId","connectVertices","func","rowFirstSegmentId","colFirstSegmentId","pixel","PROCESS_LAYERS","backgroundColors","selectedSegmentIds","arguments","dimensions","min","max","sum","isFinite","CALCULATE_REQUIRED_DIMENSIONS","width","height","Uint8ClampedArray","segmentLookupData","segmentLookupIdMapping","colorFinder","hasSelectedSegments","a","b","TYPE_SORT_MAPPING","wall","_layer$metaData$segme","_layer$metaData$segme2","_layer$metaData$segme3","getColor","console","error","concat","g","segmentLookupId","offset","imgDataOffset","left","top","fromEntries","log","cachedLayers","window","self","postMessage","ready","addEventListener","evt","data","mapLayers","rendered","buffer","transfer"],"sourceRoot":""}